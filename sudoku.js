// Generated by LiveScript 1.4.0
/*
a mangling of Peter Norvig's famous sudoku solver in LiveScript
*/
(function(){
  var assert, ref$, concat, lines, tail, listsToObj, chars, unique, fold1, join, replicate, minimumBy, objToPairs, reject, cross, digits, rows, cols, squares, unitlist, c, r, rs, cs, units, res$, i$, len$, s, u, peers, test, parseGrid, gridValues, assign, eliminate, done, some, dup, search, solve, display, out$ = typeof exports != 'undefined' && exports || this;
  assert = require('assert');
  ref$ = require('prelude-ls'), concat = ref$.concat, lines = ref$.lines, tail = ref$.tail, listsToObj = ref$.listsToObj, chars = ref$.chars, unique = ref$.unique, fold1 = ref$.fold1, join = ref$.join, replicate = ref$.replicate, minimumBy = ref$.minimumBy, objToPairs = ref$.objToPairs, reject = ref$.reject;
  cross = function(as, bs){
    var i$, len$, a, j$, len1$, b, results$ = [];
    for (i$ = 0, len$ = as.length; i$ < len$; ++i$) {
      a = as[i$];
      for (j$ = 0, len1$ = bs.length; j$ < len1$; ++j$) {
        b = bs[j$];
        results$.push(a + b);
      }
    }
    return results$;
  };
  digits = '123456789';
  rows = 'ABCDEFGHI';
  cols = digits;
  squares = cross(rows, cols);
  unitlist = (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = cols).length; i$ < len$; ++i$) {
      c = ref$[i$];
      results$.push(cross(rows, c));
    }
    return results$;
  }()).concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = rows).length; i$ < len$; ++i$) {
      r = ref$[i$];
      results$.push(cross(r, cols));
    }
    return results$;
  }()), (function(){
    var i$, ref$, len$, j$, ref1$, len1$, results$ = [];
    for (i$ = 0, len$ = (ref$ = ['ABC', 'DEF', 'GHI']).length; i$ < len$; ++i$) {
      rs = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = ['123', '456', '789']).length; j$ < len1$; ++j$) {
        cs = ref1$[j$];
        results$.push(cross(rs, cs));
      }
    }
    return results$;
  }()));
  res$ = {};
  for (i$ = 0, len$ = squares.length; i$ < len$; ++i$) {
    s = squares[i$];
    res$[s + ""] = (fn$());
  }
  units = res$;
  res$ = {};
  for (i$ = 0, len$ = squares.length; i$ < len$; ++i$) {
    s = squares[i$];
    res$[s + ""] = unique(
    reject((fn1$))(
    concat(
    units[s])));
  }
  peers = res$;
  out$.test = test = function(){
    var i$, ref$, len$, s;
    assert.strictEqual(81, squares.length);
    assert.strictEqual(27, unitlist.length);
    for (i$ = 0, len$ = (ref$ = squares).length; i$ < len$; ++i$) {
      s = ref$[i$];
      assert.strictEqual(3, units[s].length);
      assert.strictEqual(20, peers[s].length);
    }
    assert.deepEqual(units['C2'], [['A2', 'B2', 'C2', 'D2', 'E2', 'F2', 'G2', 'H2', 'I2'], ['C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9'], ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']]);
    assert.deepEqual(peers['C2'], ['A2', 'B2', 'D2', 'E2', 'F2', 'G2', 'H2', 'I2', 'C1', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9', 'A1', 'A3', 'B1', 'B3']);
  };
  parseGrid = function(grid){
    var values, res$, i$, ref$, len$, s, d;
    res$ = {};
    for (i$ = 0, len$ = (ref$ = squares).length; i$ < len$; ++i$) {
      s = ref$[i$];
      res$[s + ""] = digits;
    }
    values = res$;
    for (s in ref$ = gridValues(grid)) {
      d = ref$[s];
      if (in$(d, digits)) {
        values = assign(values, s, d);
      }
    }
    return values;
  };
  gridValues = function(grid){
    return listsToObj(squares)(
    chars(
    fold1(curry$(function(x$, y$){
      return x$ + y$;
    }))(
    grid)));
  };
  assign = function(values, s, d){
    var i$, ref$, len$;
    values[s] = d;
    for (i$ = 0, len$ = (ref$ = peers[s]).length; i$ < len$; ++i$) {
      s = ref$[i$];
      if (!eliminate(values, s, d)) {
        return false;
      }
    }
    return values;
  };
  eliminate = function(values, s, d){
    var d2, i$, ref$, len$, s2, u, dplaces, res$, j$, len1$;
    if (!in$(d, values[s])) {
      return values;
    }
    values[s] = values[s].replace(d, '');
    if (values[s].length === 0) {
      return false;
    } else if (values[s].length === 1) {
      d2 = values[s];
      for (i$ = 0, len$ = (ref$ = peers[s]).length; i$ < len$; ++i$) {
        s2 = ref$[i$];
        if (!eliminate(values, s2, d2)) {
          return false;
        }
      }
    }
    for (i$ = 0, len$ = (ref$ = units[s]).length; i$ < len$; ++i$) {
      u = ref$[i$];
      res$ = [];
      for (j$ = 0, len1$ = u.length; j$ < len1$; ++j$) {
        s = u[j$];
        if (in$(d, values[s])) {
          res$.push(s);
        }
      }
      dplaces = res$;
      if (dplaces.length === 0) {
        return false;
      } else if (dplaces.length === 1) {
        if (!assign(values, dplaces[0], d)) {
          return false;
        }
      }
    }
    return values;
  };
  done = function(values){
    var i$, ref$, len$, s;
    for (i$ = 0, len$ = (ref$ = squares).length; i$ < len$; ++i$) {
      s = ref$[i$];
      if (values[s].length !== 1) {
        return false;
      }
    }
    return true;
  };
  some = function(seq){
    var i$, len$, e;
    for (i$ = 0, len$ = seq.length; i$ < len$; ++i$) {
      e = seq[i$];
      if (e) {
        return e;
      }
    }
    return false;
  };
  dup = function(obj){
    var d, key;
    d = {};
    for (key in obj) {
      d[key] = obj[key];
    }
    return d;
  };
  search = function(values){
    var sq, i$, ref$, len$, d, that;
    if (!values) {
      return false;
    }
    if (done(values)) {
      return values;
    }
    sq = function(it){
      return it[0];
    }(
    minimumBy(function(it){
      return it[1].length;
    })(
    reject(function(it){
      return it[1].length < 2;
    })(
    objToPairs(
    values))));
    for (i$ = 0, len$ = (ref$ = values[sq]).length; i$ < len$; ++i$) {
      d = ref$[i$];
      if (that = search(assign(dup(values), sq, d))) {
        return that;
      }
    }
    return false;
  };
  out$.solve = solve = function(grid){
    return search(parseGrid(grid));
  };
  out$.display = display = function(xs){
    var width, line, i$, ref$, len$, r, output, j$, ref1$, len1$, c;
    width = 3;
    line = join('+', replicate(3, repeatString$('--', width)));
    for (i$ = 0, len$ = (ref$ = rows).length; i$ < len$; ++i$) {
      r = ref$[i$];
      output = '';
      for (j$ = 0, len1$ = (ref1$ = cols).length; j$ < len1$; ++j$) {
        c = ref1$[j$];
        output += xs[r + c] + ' ';
        if (in$(c, '36')) {
          output += '|';
        }
      }
      console.log(output);
      if (in$(r, 'CF')) {
        console.log(line);
      }
    }
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = unitlist).length; i$ < len$; ++i$) {
      u = ref$[i$];
      if (in$(s, u)) {
        results$.push(u);
      }
    }
    return results$;
  }
  function fn1$(it){
    return it === s;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);
